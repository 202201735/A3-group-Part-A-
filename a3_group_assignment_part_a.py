# -*- coding: utf-8 -*-
"""A3 group assignment Part A

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ROUfNQ3i5MkkERWgro6P6ApvOHdMWH93
"""

#Requirement 1
import datetime

class Post:
    def __init__(self, post_id, datetime, content, author):
        self.post_id = post_id
        self.datetime = datetime
        self.content = content
        self.author = author
        self.views = 0  # Initialize views to zero

    def __str__(self):
        return f"Post ID: {self.post_id}, Date: {self.datetime}, Content: {self.content}, Author: {self.author}, Views: {self.views}"

class SocialMediaManager:
    def __init__(self):
        self.posts_by_date = {}  # Dictionary to store posts by datetime

    def add_post(self, post):
        # Use the datetime as the unique key for the hash table
        # If there's a post with the same datetime, it will be replaced. (In reality, we would want to handle this case)
        self.posts_by_date[post.datetime] = post

    def find_post_by_date(self, date):
        # Attempt to retrieve the post using the date as the key
        return self.posts_by_date.get(date, None)

# Test case 1
manager = SocialMediaManager()

# Create a post
post_date = datetime.datetime.now()
new_post = Post(post_id=1, datetime=post_date, content="Hello World!", author="Noora")

# Add the post to the manager
manager.add_post(new_post)

# Retrieve the post by date
found_post = manager.find_post_by_date(post_date)
if found_post:
    print("Post found:", found_post)
else:
    print("Post not found.")
# Create instance of SocialMediaManager
manager = SocialMediaManager()

# Test Case 2: Add and retrieve a post
post_date_1 = datetime.datetime(2024, 4, 12, 12, 0, 0)
post_1 = Post(post_id=101, datetime=post_date_1, content="First post content", author="User1")
manager.add_post(post_1)

# Try to retrieve the post
retrieved_post_1 = manager.find_post_by_date(post_date_1)
assert retrieved_post_1 is not None, "Test Case 2 Failed: The post should be found."
assert retrieved_post_1.post_id == post_1.post_id, "Test Case 2 Failed: The post ID should match."
assert retrieved_post_1.content == post_1.content, "Test Case 2 Failed: The content should match."
assert retrieved_post_1.author == post_1.author, "Test Case 2 Failed: The author should match."
print("Test Case 2 Passed: Post retrieved successfully.")

# Test Case 3: Attempt to retrieve a non-existent post
post_date_2 = datetime.datetime(2024, 4, 13, 12, 0, 0)
retrieved_post_2 = manager.find_post_by_date(post_date_2)
assert retrieved_post_2 is None, "Test Case 3 Failed: No post should be found with the given datetime."
print("Test Case 3 Passed: No post found as expected.")

#Requirment 2
from sortedcontainers import SortedDict
import datetime

class SocialMediaManager:
    def __init__(self):
        # Initialize a SortedDict to store posts sorted by their datetime
        self.posts_by_date = SortedDict()

    def add_post(self, post):
        # Add a post to the sorted dictionary with the post's datetime as the key
        self.posts_by_date[post.datetime] = post

    def find_posts_in_range(self, start_datetime, end_datetime):
        # Use bisect_left to find the starting index of posts from the start_datetime
        start_index = self.posts_by_date.bisect_left(start_datetime)
        # Use bisect_right to find the ending index just after the end_datetime
        end_index = self.posts_by_date.bisect_right(end_datetime)

        # Retrieve and return all posts within the specified datetime range using list comprehension
        return [self.posts_by_date.values()[i] for i in range(start_index, end_index)]

# Test Case 4 Example of how a Post class might be defined

# Instantiate the social media manager
manager = SocialMediaManager()
# Create and add posts to the manager
manager.add_post(Post(1, datetime.datetime(2024, 4, 10, 12, 0, 0), "Post one", "Abdulla"))
manager.add_post(Post(2, datetime.datetime(2024, 4, 11, 15, 0, 0), "Post two", "Ahmad"))

# Define the range of dates to search for posts
start_date = datetime.datetime(2024, 4, 10)
end_date = datetime.datetime(2024, 4, 12)
# Retrieve posts within the defined range
posts_in_range = manager.find_posts_in_range(start_date, end_date)

# Print out the posts found within the range
for post in posts_in_range:
    print(post)

#requirement 3
import heapq

class Post:
    def __init__(self, post_id, datetime, content, author, views=0):
        self.post_id = post_id
        self.datetime = datetime
        self.content = content
        self.author = author
        self.views = views

    def __lt__(self, other):
        # Modify less-than operator to implement max-heap based on the number of views
        return self.views > other.views

    def add_view(self):
        # Increment the view count of the post by 1
        self.views += 1

    def __str__(self):
        # Customize the string representation of the Post object
        return f"Post ID: {self.post_id}, Views: {self.views}, Content: {self.content}"

class SocialMediaManager:
    def __init__(self):
        # Initialize a min-heap and a map to keep track of posts by their ID
        self.heap = []
        self.post_map = {}

    def add_post(self, post):
        # Add a post to the heap and map for quick access and priority management
        heapq.heappush(self.heap, post)
        self.post_map[post.post_id] = post

    def update_views(self, post_id):
        # Update the views of a post if it exists, and reorganize the heap
        if post_id in self.post_map:
            self.post_map[post_id].add_view()
            # Efficient re-heapification might require a more optimized approach in a real scenario
            heapq.heapify(self.heap)

    def get_most_viewed_post(self):
        # Return the top of the heap, i.e., the post with the most views
        if self.heap:
            return self.heap[0]
        return None

# Test Case 5
manager = SocialMediaManager()
# Adding posts with initial view counts
manager.add_post(Post(1, "2024-04-12", "Content of post 1", "Aisha", 150))
manager.add_post(Post(2, "2024-04-12", "Content of post 2", "Hessa", 250))

# Simulating adding views to post 1
manager.update_views(1)
manager.update_views(1)

# Fetching and printing the post with the most views
most_viewed_post = manager.get_most_viewed_post()
print("The post with the most views is:", most_viewed_post)